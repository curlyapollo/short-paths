# Отчёт

Мною сделана работа на 10. Четвёртым алгоритмом я выбрал дейкстру, основанную на сете, изначально дейкстра у меня на приоритетной очереди.

Во избежание выбросов, делал 5 измерений и брал среднее.

Про асимптотику сначала по теории: алгоритм Дейкстры на приоритетной очереди имеет наилучшую асимптотическую сложность O(E log V), где E - количество ребер, а V - количество вершин в графе. Алгоритм Форда-Беллмана имеет сложность O(VE), что может быть неэффективно для больших графов. Алгоритм Флойда-Уоршелла имеет сложность O(V^3), что может быть непрактичным для графов с большим количеством вершин. Алгоритм Дейкстры на сете имеет сложность O(E + V log V), но требует дополнительной памяти для хранения множества вершин. В целом, выбор алгоритма зависит от конкретной задачи и характеристик графа.


Теперь посмотрим на полученные графики:

<img width="454" alt="Снимок экрана 2023-06-14 в 23 22 19" src="https://github.com/curlyapollo/short-paths/assets/95444064/a87f55ef-eef1-41b0-a593-300ad9a94756">

Как видно на графике, все согласуется с теоретическими заключениями: обе дейкстры сильно быстрее форда-беллмана и флойда-уоршелла.

Форд-Беллман чуть медленнее Флойда-Уоршелла.

<img width="455" alt="Снимок экрана 2023-06-14 в 23 24 13" src="https://github.com/curlyapollo/short-paths/assets/95444064/781b4451-d41d-48d7-bd52-9d80991139a8">

Здесь Флойд и Форд поменялись местами. Это логично, ведь Форд-Беллман идет по рёбрам и это приводит к ускорению.

<img width="455" alt="Снимок экрана 2023-06-14 в 23 26 15" src="https://github.com/curlyapollo/short-paths/assets/95444064/e260a4dd-19a3-4daf-a3ab-66283f5376f6">

Для разреженных графов мы видим, что на сильно больших графах Форд-Беллман работает совсем быстро, наравне с дейкстрами.

Сделав графики для алгоритмов относительно числа ребер, значительных изменений я не увидел, поэтому и комментировать никак не буду.

Теперь к анализу конкретных алгоритмов:

Дейкстра на приоритетной очереди:

<img width="509" alt="Снимок экрана 2023-06-14 в 11 29 08" src="https://github.com/curlyapollo/short-paths/assets/95444064/99d6fb3e-3146-457b-a571-5449fd366343">

Тут интересная вещь: алгоритм работает на полных графах быстрее, чем на связных с плотностью 0,5. Возможно, здесь прикол именно во входных данных, а возможно – это выброс.

Форд-Беллман:

<img width="440" alt="Снимок экрана 2023-06-14 в 23 28 28" src="https://github.com/curlyapollo/short-paths/assets/95444064/89ed528d-77e9-40f9-ab4d-4d0f26a7ced3">

На данном графике видно некоторое странное поведение на полных графах, похожее на выброс, а в остально все довольно близко.

Флойд-Уоршелл:

<img width="453" alt="Снимок экрана 2023-06-14 в 23 30 32" src="https://github.com/curlyapollo/short-paths/assets/95444064/af358681-6e9d-40d1-97fe-0be0f43b14be">

Тут плотность 0.5 и 1 примерно рядом, деревья сильно быстрее.

Дейкстра на сете:

<img width="440" alt="Снимок экрана 2023-06-14 в 23 31 16" src="https://github.com/curlyapollo/short-paths/assets/95444064/b3bff270-0258-46b6-82c7-a8d6ab040392">

Всё довольно стандартно.

На ребрах комментарии излишни, так как все примерно то же самое, если интересно, можно ознакомиться в ipynb.


Проделав данную работу, можно сделать вывод, что самый удобный алгоритм – это классика, алгоритм Дейкстры на приоритетной очереди.
