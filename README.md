# Отчёт

Мною сделана работа на 10. Четвёртым алгоритмом я выбрал дейкстру, основанную на сете, изначально дейкстра у меня на приоритетной очереди.

Во избежание выбросов, делал 5 измерений и брал среднее.

Про асимптотику сначала по теории: алгоритм Дейкстры на приоритетной очереди имеет наилучшую асимптотическую сложность O(E log V), где E - количество ребер, а V - количество вершин в графе. Алгоритм Форда-Беллмана имеет сложность O(VE), что может быть неэффективно для больших графов. Алгоритм Флойда-Уоршелла имеет сложность O(V^3), что может быть непрактичным для графов с большим количеством вершин. Алгоритм Дейкстры на сете имеет сложность O(E + V log V), но требует дополнительной памяти для хранения множества вершин. В целом, выбор алгоритма зависит от конкретной задачи и характеристик графа.


Теперь посмотрим на полученные графики:

<img width="511" alt="Снимок экрана 2023-06-14 в 11 14 57" src="https://github.com/curlyapollo/short-paths/assets/95444064/8be8b466-7968-44bb-9126-3720c855bd51">

Как видно на графике, все согласуется с теоретическими заключениями: обе дейкстры сильно быстрее форда-беллмана и флойда-уоршелла.

<img width="500" alt="Снимок экрана 2023-06-14 в 11 24 18" src="https://github.com/curlyapollo/short-paths/assets/95444064/ede9c8cf-0c2d-4dc4-a4a1-26f49bdbf1b1">

Здесь то же самое, что и в предыдущем.

<img width="510" alt="Снимок экрана 2023-06-14 в 11 24 59" src="https://github.com/curlyapollo/short-paths/assets/95444064/b8c440e0-13e6-4497-bd14-3b940ffb6116">

Для разреженных графов мы видим, что на сильно больших графах Форд-Беллман работает чуть дольше Флойда-Уоршелла, а приоритетная очередь работает чуть быстрее, чем сет в алгоритме Дейкстры.

Сделав графики для алгоритмов относительно числа ребер, значительных изменений я не увидел, поэтому и комментировать никак не буду.

Теперь к анализу конкретных алгоритмов:

Дейкстра на приоритетной очереди:

<img width="509" alt="Снимок экрана 2023-06-14 в 11 29 08" src="https://github.com/curlyapollo/short-paths/assets/95444064/99d6fb3e-3146-457b-a571-5449fd366343">

Тут интересная вещь: алгоритм работает на полных графах быстрее, чем на связных с плотностью 0,5. Возможно, здесь прикол именно во входных данных, а возможно – это выброс.

Форд-Беллман:

<img width="510" alt="Снимок экрана 2023-06-14 в 11 32 01" src="https://github.com/curlyapollo/short-paths/assets/95444064/323a9a2b-9670-4f47-93bc-4c8f491edef2">

На данном графике всё довольно стандартно: самые быстрые – разреженные, самые долгие – полные. Как, впрочем, и на всех остальных алгоритмах.

Проделав данную работу, можно сделать вывод, что самый удобный алгоритм – это классика, алгоритм Дейкстры на приоритетной очереди.
